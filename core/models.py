"""
Data models for Brot
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict
from enum import Enum, auto

# Enums define a fixed set of values
class OrderStatus(Enum):
    """Possible states for an order"""
    PENDING = auto()
    FILLED = auto()
    PARTIALLY_FILLED = auto()
    CANCELLED = auto()
    REJECTED = auto()
    
class OrderType(Enum):
    """Types of orders we can place"""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"

class OrderSide(Enum):
    """ Buy or sell"""
    BUY = "buy"
    SELL = "sell"

class SignalType(Enum):
    """Types of trading signals"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    ADD_POSITION = "add"

@dataclass
class PriceData:
    """
    Represents price information for a symbol  
    dataclass decorator automatically creates __init__, __repr__, __eq__
    """
    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int

    @property
    def midpoint(self) -> float:
        """Calculate midpoint between high and low"""
        return (self.high + self.low) / 2
    
    def price_change(self, previous_close: float) -> float:
        """Calculate percentage change from previous close"""
        if previous_close == 0:
            return 0.0
        return ((self.close - previous_close) / previous_close) * 100
    
@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    timestamp: datetime
    symbol: str
    signal_type: SignalType
    strategy_name: str
    confidence: float = 1.0  # 0-1 confidence score
    reason: str = ""  # Reason for signal
    metadata: Dict = field(default_factory=dict)
    # default_factory=creates a new dict for each instance

    def __post_init__(self):
        """Validation after initialization"""
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")
        
@dataclass
class Order:
    """Represents a trading order"""
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: float
    price: Optional[float] = None  # Not needed for market orders
    stop_price: Optional[float] = None  # For stop orders
    time_in_force: str = "day" # day, GTC (good till cancelled), ioc, fok
    order_id: Optional[str] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_qty: float = 0
    filled_avg_price: float = 0
    submitted_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None

    @property
    def is_filled(self) -> bool:
        """Check if order is completely filled"""
        return self.status == OrderStatus.FILLED
    @property
    def is_buy(self) -> bool:
        """Check if this is a buy order"""
        return self.side == OrderSide.BUY

@dataclass
class Position:
    """Represents a current position"""
    symbol: str
    quantity: float
    avg_entry_price: float
    current_price: float
    opened_at: datetime
    last_updated: datetime

    @property
    def market_value(self) -> float:
        """Current market value position"""
        return self.quantity * self.current_price

    @property
    def cost_basis(self) -> float:
        """Total cost of position"""
        return self.quantity * self.avg_entry_price

    @property
    def unrealized_pnl(self) -> float:
        """ Unrealized profit/loss """
        return  self.market_value - self.cost_basis 
    
    @property
    def unrealized_pnl_percent(self) -> float:
        """ Unrealized profit/loss as percentage """
        if self.cost_basis == 0:
            return 0
        return (self.unrealized_pnl / self.cost_basis) * 100
    
    @property
    def days_held(self) -> int:
        """Number of days position has been held"""
        return (datetime.now() - self.opened_at).days

@dataclass
class Trade:
    """Represents a completed trade"""
    trade_id: str
    symbol: str
    side: OrderSide
    quantity: float
    price: float
    timestamp: datetime
    order_id: str
    commission: float = 0.0

    @property
    def total_value(self) -> float:
        """Total value of the trade including commission"""
        value = self.quantity * self.price
        if self.side == OrderSide.BUY:
            return value + self.commission
        else:
            return value - self.commission